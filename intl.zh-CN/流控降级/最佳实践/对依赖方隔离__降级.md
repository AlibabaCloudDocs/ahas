# 对依赖方隔离/降级 {#concept_s1j_k4b_mgb .concept}

除了根据服务能力进行流量控制以外，还有一种常见的场景，即对依赖方进行隔离/降级。

## 场景 {#section_bbr_4th_mgb .section}

一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库、第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。

然而，这个被依赖模块的稳定性是不能保证的。如果这个依赖的服务出现了不稳定的情况，请求的响应时间变长，那么，调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽自身的线程数，服务本身也变得不可用。

以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层渲染，最终导致整个链路都不可用。

对这种情况，我们要对依赖方隔离／降级。

## 并发线程数限流 {#section_oz2_l4b_mgb .section}

对于应用的强依赖，推荐您配置线程数模式的限流，来保证自身免于不稳定服务所影响。

采用基于线程数的限流模式后，您不需要再显式地去进行线程池隔离。Sentinel 会控制资源的线程数，超出的请求直接拒绝，直到堆积的线程处理完成，可以达到信号量隔离的效果。

-   **示例**

    假设当前服务 A 依赖两个远程服务方法 `sayHello(java.lang.String)` 和 `doAnother()`。前者远程调用的响应时间 为 1s-1.5s 之间，后者 RT 非常小（30 ms 左右）。

    假设当前服务 A 依赖两个远程服务方法 `sayHello(java.lang.String)` 和 `doAnother()`。前者远程调用的响应时间 为 1s-1.5s 之间，后者 RT 非常小（30 ms 左右）。

    服务 A 端设两个远程方法 thread count 为 5。

    如果， 每隔 50 ms 左右向线程池投入两个任务，作为消费者分别远程调用对应方法，持续 10 次。

    我们可以看到， `sayHello` 方法被限流 5 次，因为后面调用的时候前面的远程调用还未返回（RT 高）；而 `doAnother()` 调用则不受影响。

    线程数目超出时，快速失败能够有效地防止自己被慢调用所影响。


## 服务降级 {#section_pz2_l4b_mgb .section}

当服务依赖于多个下游服务，而某个下游服务调用非常慢时，会严重影响当前服务的调用。

利用 Sentinel 熔断降级的功能，为调用端配置基于平均 RT 的降级规则。这样当调用链路中某个服务调用的平均 RT 升高，在一定的次数内超过配置的 RT 阈值，Sentinel 就会对此调用资源进行降级操作，接下来的调用都会立刻拒绝，直到过了一段设定的时间后才恢复，从而保护服务不被调用端短板所影响。

同时可以配合 fallback 功能使用，在被降级的时候提供相应的处理逻辑。

